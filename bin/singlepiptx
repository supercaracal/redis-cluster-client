#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/setup'
require 'redis_cluster_client'

module SinglePipTxDebug
  WAIT_SEC = 2.0

  module_function

  def spawn_single(cli)
    Thread.new(cli) do |r|
      role = '     Single'
      keys = %w[single1 single3 single4].freeze

      loop do
        keys.each do |key|
          handle_errors(role) do
            reply = r.call('incr', key)
            log "#{role}: #{key}=#{reply}"
          end
        end
      ensure
        sleep WAIT_SEC
      end
    rescue StandardError => e
      log "#{role}: dead: #{e.class}: #{e.message}"
      raise
    end
  end

  def spawn_pipeline(cli) # rubocop:disable Metrics/AbcSize
    Thread.new(cli) do |r|
      role = '   Pipeline'
      keys = %w[pipeline1 pipeline2 pipeline4].freeze

      loop do
        handle_errors(role) do
          reply = r.pipelined do |pi|
            keys.each do |key|
              pi.call('incr', key)
            end
          end

          keys.each_with_index do |key, i|
            log "#{role}: #{key}=#{reply[i]}"
          end
        end
      ensure
        sleep WAIT_SEC
      end
    rescue StandardError => e
      log "#{role}: dead: #{e.class}: #{e.message}"
      raise
    end
  end

  def spawn_transaction(cli) # rubocop:disable Metrics/AbcSize
    Thread.new(cli) do |r|
      role = 'Transaction'
      keys = %w[transaction1 transaction3 transaction4].freeze
      i = 0

      loop do
        keys.each do |key|
          handle_errors(role) do
            reply = r.multi(watch: i.odd? ? [key] : nil) do |tx|
              i += 1
              tx.call('incr', key)
              tx.call('incr', key)
            end

            log "#{role}: #{key}=#{reply[1]}"
          end
        end
      ensure
        sleep WAIT_SEC
      end
    rescue StandardError => e
      log "#{role}: dead: #{e.class}: #{e.message}"
      raise
    end
  end

  def handle_errors(role) # rubocop:disable Metrics/AbcSize
    yield
  rescue RedisClient::ConnectionError, RedisClient::Cluster::InitialSetupError, RedisClient::Cluster::NodeMightBeDown => e
    log "#{role}: #{e.class}"
  rescue RedisClient::CommandError => e
    log "#{role}: #{e.class}: #{e.message}"
    raise unless e.message.start_with?('CLUSTERDOWN')
  rescue RedisClient::Cluster::ErrorCollection => e
    log "#{role}: #{e.class}: #{e.message}"
    raise unless e.errors.values.all? do |err|
      err.message.start_with?('CLUSTERDOWN') || err.is_a?(::RedisClient::ConnectionError)
    end
  rescue StandardError => e
    log "#{role}: #{e.class}: #{e.message}"
    raise
  end

  def log(msg)
    print "#{msg}\n"
  end
end

clients = Array.new(3) { RedisClient.cluster(connect_with_original_config: true).new_client }
threads = []

Signal.trap(:INT) do
  threads.each(&:exit)
  clients.each(&:close)
  SinglePipTxDebug.log("\nBye bye")
  exit 0
end

threads << SinglePipTxDebug.spawn_single(clients[0])
threads << SinglePipTxDebug.spawn_pipeline(clients[1])
threads << SinglePipTxDebug.spawn_transaction(clients[2])
threads.each(&:join)
