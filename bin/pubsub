#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/setup'
require 'redis_cluster_client'

module PubSubDebug
  WAIT_SEC = 1.0

  module_function

  def spawn_publisher(cli, chans)
    Thread.new(cli, chans) do |r, cs|
      role = ' Publisher'
      i = 0

      loop do
        msg = format('%05d', i)
        i += 1
        cs.each do |c|
          handle_errors(role) do
            r.call('spublish', c, msg)
            log "#{role}: sent: #{c}=#{msg}"
          end
        end
      ensure
        sleep WAIT_SEC * 3
      end
    rescue StandardError => e
      log "#{role}: dead: #{e.class}: #{e.message}"
      raise
    end
  end

  def spawn_subscriber(cli, chans) # rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity
    Thread.new(cli, chans) do |r, cs|
      role = 'Subscriber'
      ps = nil

      loop do
        ps = r.pubsub
        cs.each { |c| ps.call('ssubscribe', c) }
        break
      rescue StandardError => e
        log "#{role}: init: #{e.class}: #{e.message}"
        ps&.close
      ensure
        sleep 1.0
      end

      loop do
        handle_errors('Subscriber') do
          case e = ps.next_event(0.01)
          when nil then log "#{role}: recv: nil"
          when Array
            log "#{role}: recv: #{e}"
            case e.first
            when 'sunsubscribe' then ps.call('ssubscribe', c)
            end
          end
        end
      ensure
        sleep WAIT_SEC
      end
    rescue StandardError, SignalException => e
      log "#{role}: dead: #{e.class}: #{e.message}"
      ps&.close
      raise
    end
  end

  def handle_errors(role)
    yield
  rescue RedisClient::ConnectionError, RedisClient::Cluster::InitialSetupError, RedisClient::Cluster::NodeMightBeDown => e
    log "#{role}: recv: #{e.class}"
  rescue RedisClient::CommandError => e
    log "#{role}: recv: #{e.class}: #{e.message}"
    raise unless e.message.start_with?('CLUSTERDOWN')
  rescue StandardError => e
    log "#{role}: recv: #{e.class}: #{e.message}"
    raise
  end

  def log(msg)
    print "#{msg}\n"
  end
end

clients = Array.new(2) { RedisClient.cluster(connect_with_original_config: true).new_client }
threads = []
channels = %w[chan1 chan2 chan3].freeze

Signal.trap(:INT) do
  threads.each(&:exit)
  clients.each(&:close)
  PubSubDebug.log("\nBye bye")
  exit 0
end

threads << PubSubDebug.spawn_subscriber(clients[0], channels)
threads << PubSubDebug.spawn_publisher(clients[1], channels)
threads.each(&:join)
